<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>python生成器 | 佘泽健的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content=".本集概览1.生成器可以避免一次性生成整个列表2.生成器函数的运行过程解析及状态保存3.生成器表达式的使用方法4.生成器表达式的可迭代特性之前我们介绍了列表解析式，他的优点很多，比如运行速度快、编写简单，但是有一点我们不要忘了，他是一次性生成整个列表。如果整个列表非常大，这对内存也同样会造成很大压力，想要实现内存的节约，可以将列表解析式转换为生成器表达式。今天这一集，就单聊生成器。1.避免一次性生">
<meta property="og:type" content="article">
<meta property="og:title" content="python生成器">
<meta property="og:url" content="https://Gakki1234.github.io/2018/10/07/python生成器/index.html">
<meta property="og:site_name" content="佘泽健的博客">
<meta property="og:description" content=".本集概览1.生成器可以避免一次性生成整个列表2.生成器函数的运行过程解析及状态保存3.生成器表达式的使用方法4.生成器表达式的可迭代特性之前我们介绍了列表解析式，他的优点很多，比如运行速度快、编写简单，但是有一点我们不要忘了，他是一次性生成整个列表。如果整个列表非常大，这对内存也同样会造成很大压力，想要实现内存的节约，可以将列表解析式转换为生成器表达式。今天这一集，就单聊生成器。1.避免一次性生">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-07T04:45:19.614Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python生成器">
<meta name="twitter:description" content=".本集概览1.生成器可以避免一次性生成整个列表2.生成器函数的运行过程解析及状态保存3.生成器表达式的使用方法4.生成器表达式的可迭代特性之前我们介绍了列表解析式，他的优点很多，比如运行速度快、编写简单，但是有一点我们不要忘了，他是一次性生成整个列表。如果整个列表非常大，这对内存也同样会造成很大压力，想要实现内存的节约，可以将列表解析式转换为生成器表达式。今天这一集，就单聊生成器。1.避免一次性生">
  
    <link rel="alternate" href="/atom.xml" title="佘泽健的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">佘泽健的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Just to be better！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Gakki1234.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-python生成器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/07/python生成器/" class="article-date">
  <time datetime="2018-10-07T04:41:08.000Z" itemprop="datePublished">2018-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      python生成器
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>.本集概览<br>1.生成器可以避免一次性生成整个列表<br>2.生成器函数的运行过程解析及状态保存<br>3.生成器表达式的使用方法<br>4.生成器表达式的可迭代特性<br>之前我们介绍了列表解析式，他的优点很多，比如运行速度快、编写简单，但是有一点我们不要忘了，他是一次性生成整个列表。如果整个列表非常大，这对内存也同样会造成很大压力，想要实现内存的节约，可以将列表解析式转换为生成器表达式。<br>今天这一集，就单聊生成器。<br>1.避免一次性生成整个列表<br>避免一次性生成整个结果列表的本质是在需要的时候才逐次产生结果，而不是立即产生全部的结果，Python中有两种语言结构可以实现这种思路。<br>一个是生成器函数。外表去像是一个函数，但是没有用return语句一次性的返回整个结果对象列表，取而代之的是使用yield语句一次返回一个结果。<br>另一个是生成器表达式。类似于上一小节的列表解析，但是方括号换成了圆括号，他们返回按需产生的一个结果对象，而不是构建一个结果列表。<br>这个“按需”指的是在迭代的环境中，每次迭代按需产生一个对象，因此，上述二者都不会一次性构建整个列表，从而节约了内存空间。<br>2.生成器函数<br>下面具体结合例子说说生成器函数。<br>2.1.运行过程分析<br>首先，我们还没有详细介绍过函数，先简单说一下，常规函数接受输入的参数然后立即送回单个结果，之后这个函数调用就结束了。<br>但生成器函数却不同，他通过yield关键字返回一个值后，还能从其退出的地方继续运行，因此可以随时间产生一系列的值。他们自动实现了迭代协议，并且可以出现在迭代环境中。<br>运行的过程是这样的：生成器函数返回一个迭代器，for循环等迭代环境对这个迭代器不断调用next函数，不断的运行到下一个yield语句，逐一取得每一个返回值，直到没有yield语句可以运行，最终引发StopIteration异常。看，这个过程是不是很熟悉。<br>首先，下面这个例子证实了生成器函数返回的是一个迭代器<br>代码片段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_squares</span><span class="params">(num)</span>:</span></span><br><span class="line">   <span class="keyword">for</span> x <span class="keyword">in</span> range(num):</span><br><span class="line">       <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">G = gen_squares(<span class="number">5</span>)</span><br><span class="line">print(G)</span><br><span class="line">print(iter(G))</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object gen_squares at 0x0000000002402558&gt;</span><br><span class="line">&lt;generator object gen_squares at 0x0000000002402558&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后再用手动模拟循环的方式来看看生成器函数的运行过程，你会发现和前面介绍过的熟悉场景并无二致。<br>代码片段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_squares</span><span class="params">(num)</span>:</span></span><br><span class="line">   <span class="keyword">for</span> x <span class="keyword">in</span> range(num):</span><br><span class="line">       <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">G = gen_squares(<span class="number">3</span>)</span><br><span class="line">print(G)</span><br><span class="line">print(iter(G))</span><br><span class="line">print(next(G))</span><br><span class="line">print(next(G))</span><br><span class="line">print(next(G))</span><br><span class="line">print(next(G))</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<ol>
<li><generator object="" gen_squares="" at="" 0x00000000021c2558=""></generator></li>
<li><generator object="" gen_squares="" at="" 0x00000000021c2558=""></generator></li>
<li>0</li>
<li>1</li>
<li>4</li>
<li>Traceback (most recent call last):</li>
<li>File “E:/12homework/12homework.py”, line 10, in <module></module></li>
<li>print(next(G))</li>
<li><p>StopIteration<br>那这么看，在for循环等真正的使用场景中使用也不难了 代码片段：</p>
</li>
<li><p>def gen_squares(num):</p>
</li>
<li>for x in range(num):</li>
<li>yield x ** 2</li>
<li>for i in gen_squares(5):</li>
<li><p>print(i, end=’ ‘)<br>运行结果：</p>
</li>
<li><p>0 1 4 9 16<br>2.2.状态保存<br>我们进一步来说说生成器函数里状态保存的话题。在每次循环的时候，生成器函数都会在yield处产生一个值，并将其返回给调用者，即for循环。然后在yield处保存内部状态，并挂起中断退出。在下一轮迭代调用时，从yield的地方继续执行，并且沿用上一轮的函数内部变量的状态，直到内部循环过程结束。<br>关于这个问题，具体可以看看这个例子：<br>代码片段：</p>
</li>
<li><p>def gen_squares(num):</p>
</li>
<li>for x in range(num):</li>
<li>yield x ** 2</li>
<li>print(‘x={}’.format(x))</li>
<li>for i in gen_squares(4):</li>
<li>print(‘x ** 2={}’.format(i))</li>
<li><p>print(‘————–’)<br>运行结果：</p>
</li>
<li><p>x ** 2=0</p>
</li>
<li><hr>
</li>
<li>x=0</li>
<li>x ** 2=1</li>
<li><hr>
</li>
<li>x=1</li>
<li>x ** 2=4</li>
<li><hr>
</li>
<li>x=2</li>
<li>x ** 2=9</li>
<li><hr>
</li>
<li><p>x=3<br>我们不难发现，生成器函数计算出x的平方后就挂起退出了，但他仍然保存了此时x的值，而yield后的print语句会在for循环的下一轮迭代中首先调用，此时x的值即是上一轮退出时保存的值。<br>3.生成器表达式<br>再说说生成器表达式吧。<br>3.1.使用方法<br>列表解析式已经是一个不错的选择，从内存使用的角度而言，生成器更优，因为他不用一次性生成整个对象列表，这二者之间如何转化呢？<br>生成器表达式写法上很像列表解析式，但是外面的方括号换成了圆括号，结果大不同，简单的看看： 代码片段：</p>
</li>
<li><p>print([x ** 2 for x in range(5)])</p>
</li>
<li><p>print((x ** 2 for x in range(5)))<br>运行结果：</p>
</li>
<li><p>[0, 1, 4, 9, 16]</p>
</li>
<li><p>&lt;generator object <genexpr> at 0x0000000002212558&gt;<br>方括号是熟悉的列表解析式，一次性返回整个列表，圆括号是生成器表达式，返回一个生成器对象，而不是一次性生成整个列表。<br>3.2.适用于迭代环境<br>同时他支持迭代协议，适用于所有的迭代环境，略举几个例子： 代码片段：</genexpr></p>
</li>
<li><p>for x in (x ** 2 for x in range(5)):</p>
</li>
<li><p>print(x, end=’,’)<br>运行结果：</p>
</li>
<li><p>0,1,4,9,16,<br>代码片段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">print</span>(sum(x ** 2 <span class="keyword">for</span> x <span class="keyword">in</span> range(5)))</span><br><span class="line">``` </span><br><span class="line">运行结果：</span><br><span class="line">``` bash</span><br><span class="line">$ 30</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>代码片段：</p>
<ol>
<li><p>print(sorted((x ** 2 for x in range(5)), reverse=True))<br>运行结果：</p>
</li>
<li><p>[16, 9, 4, 1, 0]<br>代码片段：</p>
</li>
<li><p>print(list(x ** 2 for x in range(5)))<br>运行结果：</p>
</li>
<li><p>[0, 1, 4, 9, 16]<br>3.3.集合解析式与生成器对象<br>集合解析式等效于将生成器对象传入到list、set、dict等函数中作为构造参数 代码片段：</p>
</li>
<li><p>set(f(x) for x in S if P(x))</p>
</li>
<li>{f(x) for x in S if P(x)}</li>
<li>{key:val for (key, val) in zip(keys, vals)}</li>
<li>dict(zip(keys, vals))</li>
<li>{x:f(x) for x in items}<br>dict((x, f(x)) for x in items)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Gakki1234.github.io/2018/10/07/python生成器/" data-id="cjmydy34m0002pw7yjbxizojj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/10/07/python/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Python参数传递</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/07/python生成器/">python生成器</a>
          </li>
        
          <li>
            <a href="/2018/10/07/python/">Python参数传递</a>
          </li>
        
          <li>
            <a href="/2018/10/07/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 SZJ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>