{"meta":{"title":"佘泽健的博客","subtitle":"Just to be better！","description":"一只爱学习的程序猿","author":"SZJ","url":"https://github.com/Gakki1234"},"pages":[{"title":"","date":"un00fin00","updated":"un00fin00","comments":false,"path":"categories/index.html","permalink":"https://github.com/Gakki1234/categories/index.html","excerpt":"","text":""},{"title":"","date":"un00fin00","updated":"un00fin00","comments":false,"path":"tags/index.html","permalink":"https://github.com/Gakki1234/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"python实现常见算法","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/10/11/python实现常见算法/","link":"","permalink":"https://github.com/Gakki1234/2018/10/11/python实现常见算法/","excerpt":"","text":"冒泡排序原理：列表中两个相邻的数，如果前一个数比后一个数大，就做交换。一共需要遍历列表的次数是len(lst)-1 时间复杂度：O(n^2)def bubble_sort(lst): for i in range(len(lst)-1): # 这是需要循环遍历多少次 change = False # 做一个标志变量 for j in range(len(lst)-i-1): # 每次数组中的无序区 if lst[j] &gt;lst[j+1]: lst[j],lst[j+1] = lst[j+1],lst[j] change = True # 每次遍历，如果进来排序的话，就会改变change的值 if not change: # 如果change没有改变，那就表示当前的序列是有序的，直接跳出循环即可 return lst = [1, 2, 3, 5, 44]bubble_sort(lst)print(lst) 选择排序原理：每次遍历找到当下数组最小的数，并把它放到第一个位置，下次遍历剩下的无序区def select_sort(lst): for i in range(len(lst) - 1): # 当前需遍历的次数 min_loc = i # 当前最小数的位置 for j in range(i+1, len(lst)): # 无序区 if lst[j] &lt; lst[min_loc]: # 如果有更小的数 min_loc = j # 最小数的位置改变 if min_loc != i: lst[i], lst[min_loc] = lst[min_loc], lst[i] # 把最小数和无序区第一个数交换交换 lst = [1, 2, 44, 3, 5]select_sort(lst)print(lst) 插入排序原理：列表分为有序区和无序区，有序区是一个相对有序的序列，认为一开始的时候有序区有一值每次从无序区选择一个值，放到有序区，直到无序区为空def insert_sort(lst): for i in range(1,len(lst)): # 从1开始遍历表示无序区从1开始，有序区初始有一个值 tmp = lst[i] # tmp表示拿到的无序区的第一张牌 j = i - 1 # j表示有序区的最后一个值 while j &gt;= 0 and lst[j] &gt; tmp: # 当有序区有值，并且有序区的值比无序区拿到的值大就一直循环 lst[j+1] = lst[j] # 有序区的值往后移 j -= 1 # 找到上一个有序区的值，然后再循环 lst[j+1] = tmp # 跳出循环之后，只有j+1的位置是空的，要把当下无序区的值放到j+1的位置 lst = [1, 2, 44, 3, 5]insert_sort(lst)print(lst) 二分插入：实际上并没有优化的效果 def insert_sort(lst): for i in range(1, len(lst)): left = 0 right = i - 1 tmp = lst[i] while left &lt;= right: mid = int((left + right) / 2) if tmp &gt;= lst[mid]: left = mid + 1 if tmp &lt; lst[mid]: right = mid - 1 for j in range(i - 1, left - 1, -1): # [i-1,left] lst[j + 1] = lst[j] lst[left] = tmp return lst lst = [1, 2, 44, 3, 5]insert_sort(lst)print(lst) 4、快速排序 思路：取第一个元素，让它归位，就是放到一个位置，使它左边的都比它小，右边的都比它大，然后递归 先归位，后递归 时间复杂度：O(nlog(n)) 最坏情况： 最坏情况下的时间复杂度是O(n2) 标志数的左边或者右边只有一个数 解决方法：不要找第一个元素，随机找一个元素 def parttion(lst, left, right): i = left j = right tmp = lst[i] # 把此次循环的标志数存起来 while i &lt; j: while i &lt; j and lst[j] &gt; tmp: # 先从右边开始找比标志数小的，有的话跳出循环 j -= 1 lst[i] = lst[j] # 跳出循环之后，把这个比标志数小的值放到标志数的位置 while i &lt; j and lst[i] &lt; tmp: # 左边的排序方法和右边一样 i += 1 lst[j] = lst[i] lst[i] = tmp # 整个排序结束之后，把一开始的标志数放回空位 return i def quick_sort(lst, left, right): if left &lt; right: # 至少有两个元素 p = parttion(lst, left, right) quick_sort(lst, left, p-1) quick_sort(lst, p+1, right) lst = [1, 2, 44, 3, 5]quick_sort(lst, 0, 4)print(lst)","categories":[],"tags":[]},{"title":"06:Pod控制器应用进阶","slug":"06-Pod控制器应用进阶","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/10/07/06-Pod控制器应用进阶/","link":"","permalink":"https://github.com/Gakki1234/2018/10/07/06-Pod控制器应用进阶/","excerpt":"","text":"资源配置清单： 自主式Pod资源 资源的清单格式： 一级字段：apiVersion（group/version），kind，metadata（name，namespace，labels，annotations），spec（container），status（只读） Pod资源： spec.containers&lt;[]object&gt; - name &lt;string&gt; image &lt;string&gt; imagePullPolicy &lt;string&gt; Always，Never，IfNotPresent 修改镜像中的默认应用： command args 替换container里ENTRYPOINT和CMD 标签： key=value key：字母、数字、_、-、. value：可以为空，只能以字母或数字开头及结尾 标签选择器： 等值关系：=，==，！= 集合关系：KEY in （VALUE1,VALUE2,…） KEY not in （VALUE1,VALUE2,…） KEY !KEY 许多资源支持内嵌字段定义其使用的标签选择器： matchLabels：直接给定键值 matchExpressions：基于给定的表达式来定义使用的标签选择器，{key:&quot;KEY&quot;,operator:&quot;OPERATOR&quot;,values:[VAL1,VAL2,…]} 操作符：In,NotIn:values字段的值必须为非空列表； Exists,NotExists：values字段的值必须为空列表； nodeSelector &lt;map[string]string&gt; 节点标签选择器， nodeName &lt;string&gt; annotations:资源注解 与label不同的地方在于，它不能用于挑选资源对象，仅用于为对象提供“元数据”。 Pod的生命周期：","categories":[],"tags":[]},{"title":"05:资源清单定义入门","slug":"05-资源清单定义入门","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/10/07/05-资源清单定义入门/","link":"","permalink":"https://github.com/Gakki1234/2018/10/07/05-资源清单定义入门/","excerpt":"","text":"资源：对象 workload：Pod,ReplicaSet,Deployment,StatefulSet,DaemonSet,Job,Cronjob,…… 服务发现及均衡：Service，Ingress，…. 配置及存储：Volume，通过CSI扩展第三方存储卷 ComfigMap（当配置中心），Secret（保存敏感资源） DownwardAPI 集群级资源： Namespace，Node，Role，ClusterRole，RoleBinding，ClusterRoleBinding 元数据型资源： HPA，PodTemplate，LimitRange 创建资源的方法： apiserver仅接收JSON格式的资源定义； yaml格式提供配置清单，apiserver可自动将其转为json格式，而后再提交； 大部分资源的配置清单：五个一级字段 kubectl explain pods.metadata (查看yaml格式如何定义) apiVersion：group/version $ kubectl api-versions kind：资源类别 metadata：元数据，name，namespace，labels，annotations spec：期望的状态，disired state status：当天状态，current state，本字段由kubernetes集群维护； 每个资源的引用PATH： /api/GROUP/VERSION/namespaces/NAMESPACE/TYPE/NAME 配置清单创建资源： kubectl get pod pod_name -o yaml spec:资源对象的规格特性 例子：mkdir manifests cd manifests vim pod-demo.yaml /image/123.png kubectl create -f pod-demo.yaml kubectl logs pod-demo myapp kubectl exec -it pod-demo -c myapp -- /bin/sh kubectl delete -f pod-demo.yaml","categories":[],"tags":[]},{"title":"04:k8s应用入门","slug":"04-k8s应用入门","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/10/07/04-k8s应用入门/","link":"","permalink":"https://github.com/Gakki1234/2018/10/07/04-k8s应用入门/","excerpt":"","text":"kubectl versionkubectl cluster-infomaster： kubectl run nginx-deploy –image=nginx:1.14-alpine –port=80 –replicas=1 –dry-run=true kubectl expose deployment nginx-deploy –name=nginx –port=80 –target-port=80 –protocol=TCP kubectl get services(svc) kubectl run client –image=busybox –replicas=1 -it –restart=Never kubectl describe services nginx 查看service详细信息 kubectl get pods –show-lables=true 查看pod标签 kubectl edit svc nginx (修改服务信息) kubectl run myapp –image=ikubernetes/myapp:v1 –replicas=2 kubectl expose deployment myapp –name=myapp –port=80 pod客户端：wget -O - -q myapp kubectl scale –replicas=5 deployment myapp 动态扩展或者缩减pod副本 kubectl set image deployment myapp myapp=ikubernetes/myapp:v2 kubectl rollout status deployment myapp kubectl rollout undo deployment myapp kubectl edit svc myapp (ClusterIP 改成NodePort 集群外部可以访问)","categories":[],"tags":[]},{"title":"python生成器","slug":"python生成器","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/10/07/python生成器/","link":"","permalink":"https://github.com/Gakki1234/2018/10/07/python生成器/","excerpt":"","text":".本集概览1.生成器可以避免一次性生成整个列表2.生成器函数的运行过程解析及状态保存3.生成器表达式的使用方法4.生成器表达式的可迭代特性之前我们介绍了列表解析式，他的优点很多，比如运行速度快、编写简单，但是有一点我们不要忘了，他是一次性生成整个列表。如果整个列表非常大，这对内存也同样会造成很大压力，想要实现内存的节约，可以将列表解析式转换为生成器表达式。今天这一集，就单聊生成器。1.避免一次性生成整个列表避免一次性生成整个结果列表的本质是在需要的时候才逐次产生结果，而不是立即产生全部的结果，Python中有两种语言结构可以实现这种思路。一个是生成器函数。外表去像是一个函数，但是没有用return语句一次性的返回整个结果对象列表，取而代之的是使用yield语句一次返回一个结果。另一个是生成器表达式。类似于上一小节的列表解析，但是方括号换成了圆括号，他们返回按需产生的一个结果对象，而不是构建一个结果列表。这个“按需”指的是在迭代的环境中，每次迭代按需产生一个对象，因此，上述二者都不会一次性构建整个列表，从而节约了内存空间。2.生成器函数下面具体结合例子说说生成器函数。2.1.运行过程分析首先，我们还没有详细介绍过函数，先简单说一下，常规函数接受输入的参数然后立即送回单个结果，之后这个函数调用就结束了。但生成器函数却不同，他通过yield关键字返回一个值后，还能从其退出的地方继续运行，因此可以随时间产生一系列的值。他们自动实现了迭代协议，并且可以出现在迭代环境中。运行的过程是这样的：生成器函数返回一个迭代器，for循环等迭代环境对这个迭代器不断调用next函数，不断的运行到下一个yield语句，逐一取得每一个返回值，直到没有yield语句可以运行，最终引发StopIteration异常。看，这个过程是不是很熟悉。首先，下面这个例子证实了生成器函数返回的是一个迭代器代码片段：123456def gen_squares(num): for x in range(num): yield x ** 2G = gen_squares(5)print(G)print(iter(G)) 运行结果：12&lt;generator object gen_squares at 0x0000000002402558&gt;&lt;generator object gen_squares at 0x0000000002402558&gt; 然后再用手动模拟循环的方式来看看生成器函数的运行过程，你会发现和前面介绍过的熟悉场景并无二致。代码片段：12345678910def gen_squares(num): for x in range(num): yield x ** 2G = gen_squares(3)print(G)print(iter(G))print(next(G))print(next(G))print(next(G))print(next(G)) 运行结果：123456789&lt;generator object gen_squares at 0x00000000021C2558&gt;&lt;generator object gen_squares at 0x00000000021C2558&gt;014Traceback (most recent call last):File \"E:/12homework/12homework.py\", line 10, in &lt;module&gt;print(next(G))StopIteration 那这么看，在for循环等真正的使用场景中使用也不难了 代码片段：123451. def gen_squares(num):2. for x in range(num):3. yield x ** 24. for i in gen_squares(5):5. print(i, end=' ') 运行结果：12345678910111213141. 0 1 4 9 16``` 2.2.状态保存我们进一步来说说生成器函数里状态保存的话题。在每次循环的时候，生成器函数都会在yield处产生一个值，并将其返回给调用者，即for循环。然后在yield处保存内部状态，并挂起中断退出。在下一轮迭代调用时，从yield的地方继续执行，并且沿用上一轮的函数内部变量的状态，直到内部循环过程结束。关于这个问题，具体可以看看这个例子： 代码片段：``` python1. def gen_squares(num):2. for x in range(num):3. yield x ** 24. print('x=&#123;&#125;'.format(x))5. for i in gen_squares(4):6. print('x ** 2=&#123;&#125;'.format(i))7. print('--------------') 运行结果：1234567891011121. x ** 2=02. --------------3. x=04. x ** 2=15. --------------6. x=17. x ** 2=48. --------------9. x=210. x ** 2=911. --------------12. x=3 我们不难发现，生成器函数计算出x的平方后就挂起退出了，但他仍然保存了此时x的值，而yield后的print语句会在for循环的下一轮迭代中首先调用，此时x的值即是上一轮退出时保存的值。3.生成器表达式再说说生成器表达式吧。3.1.使用方法列表解析式已经是一个不错的选择，从内存使用的角度而言，生成器更优，因为他不用一次性生成整个对象列表，这二者之间如何转化呢？生成器表达式写法上很像列表解析式，但是外面的方括号换成了圆括号，结果大不同，简单的看看： 代码片段：121. print([x ** 2 for x in range(5)])2. print((x ** 2 for x in range(5))) 运行结果：121. [0, 1, 4, 9, 16]2. &lt;generator object &lt;genexpr&gt; at 0x0000000002212558&gt; 方括号是熟悉的列表解析式，一次性返回整个列表，圆括号是生成器表达式，返回一个生成器对象，而不是一次性生成整个列表。3.2.适用于迭代环境同时他支持迭代协议，适用于所有的迭代环境，略举几个例子： 代码片段：121. for x in (x ** 2 for x in range(5)):2. print(x, end=',') 运行结果：11. 0,1,4,9,16, 代码片段：12345print(sum(x ** 2 for x in range(5)))``` 运行结果：``` bash 30 代码片段：11. print(sorted((x ** 2 for x in range(5)), reverse=True)) 运行结果：11. [16, 9, 4, 1, 0] 代码片段：11. print(list(x ** 2 for x in range(5))) 运行结果：11. [0, 1, 4, 9, 16] 3.3.集合解析式与生成器对象集合解析式等效于将生成器对象传入到list、set、dict等函数中作为构造参数 代码片段：1234561. set(f(x) for x in S if P(x))2. &#123;f(x) for x in S if P(x)&#125;3. &#123;key:val for (key, val) in zip(keys, vals)&#125;4. dict(zip(keys, vals))5. &#123;x:f(x) for x in items&#125;dict((x, f(x)) for x in items)","categories":[],"tags":[]},{"title":"Python参数传递","slug":"python","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/10/07/python/","link":"","permalink":"https://github.com/Gakki1234/2018/10/07/python/","excerpt":"","text":"参数传递在 python 中，类型属于对象，变量是没有类型的：a=[1,2,3]a=”Runoob”以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。• 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。• 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。python 函数的参数传递：• 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。• 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/10/07/hello-world/","link":"","permalink":"https://github.com/Gakki1234/2018/10/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}